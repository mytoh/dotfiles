--- dwm.stcol	2011-10-13 11:23:27.000000000 +0900
+++ dwm.c	2011-10-13 11:37:43.000000000 +0900
@@ -48,7 +48,6 @@
 #define LENGTH(X)               (sizeof X / sizeof X[0])
 #define MAX(A, B)               ((A) > (B) ? (A) : (B))
 #define MIN(A, B)               ((A) < (B) ? (A) : (B))
-#define MAXCOLORS               8
 #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
 #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
 #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
@@ -59,7 +58,7 @@
 enum { CurNormal, CurResize, CurMove, CurLast };        /* cursor */
 enum { ColBorder, ColFG, ColBG, ColLast };              /* color */
 enum { NetSupported, NetWMName, NetWMState,
-       NetWMFullscreen, NetActiveWindow, NetWMWindowOpacity, NetLast };     /* EWMH atoms */
+       NetWMFullscreen, NetActiveWindow, NetLast };     /* EWMH atoms */
 enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
 enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
        ClkClientWin, ClkRootWin, ClkLast };             /* clicks */
@@ -94,15 +93,13 @@
 	Client *snext;
 	Monitor *mon;
 	Window win;
-  double opacity;
 };
 
 typedef struct {
 	int x, y, w, h;
-	/*unsigned long norm[ColLast];*/
-	/*unsigned long sel[ColLast];*/
-  unsigned long colors[MAXCOLORS][ColLast];
-  Drawable drawable;
+	unsigned long norm[ColLast];
+	unsigned long sel[ColLast];
+	Drawable drawable;
 	GC gc;
 	struct {
 		int ascent;
@@ -152,7 +149,6 @@
 	unsigned int tags;
 	Bool isfloating;
 	int monitor;
-  double opacity;
 } Rule;
 
 /* function declarations */
@@ -179,14 +175,10 @@
 static Monitor *dirtomon(int dir);
 static void drawbar(Monitor *m);
 static void drawbars(void);
-/*static void drawsquare(Bool filled, Bool empty, Bool invert, unsigned long col[ColLast]);*/
-/*static void drawtext(const char *text, unsigned long col[ColLast], Bool invert);*/
-static void drawcoloredtext(char *text);
-static void drawsquare(Bool filled, Bool empty, unsigned long col[ColLast]);
-static void drawtext(const char *text, unsigned long col[ColLast], Bool pad);
+static void drawsquare(Bool filled, Bool empty, Bool invert, unsigned long col[ColLast]);
+static void drawtext(const char *text, unsigned long col[ColLast], Bool invert);
 static void enternotify(XEvent *e);
 static void expose(XEvent *e);
-static void window_opacity_set(Client *c, double opacity);
 static void focus(Client *c);
 static void focusin(XEvent *e);
 static void focusmon(const Arg *arg);
@@ -312,7 +304,6 @@
 		&& (!r->instance || strstr(instance, r->instance)))
 		{
 			c->isfloating = r->isfloating;
-      c->opacity = r->opacity;
 			c->tags |= r->tags;
 			for(m = mons; m && m->num != r->monitor; m = m->next);
 			if(m)
@@ -751,18 +742,14 @@
 	dc.x = 0;
 	for(i = 0; i < LENGTH(tags); i++) {
 		dc.w = TEXTW(tags[i]);
-		/*col = m->tagset[m->seltags] & 1 << i ? dc.sel : dc.norm;*/
-		/*drawtext(tags[i], col, urg & 1 << i);*/
-		/*drawsquare(m == selmon && selmon->sel && selmon->sel->tags & 1 << i,*/
-							 /*occ & 1 << i, urg & 1 << i, col);*/
-    col = dc.colors[ (m->tagset[m->seltags] & 1 << i ? 1:(urg & 1 << i ? 2:0))];
-    drawtext(tags[i], col, True);
-    drawsquare(m == selmon && selmon->sel && selmon->sel->tags & 1 << i, occ & 1 << i, col);
+		col = m->tagset[m->seltags] & 1 << i ? dc.sel : dc.norm;
+		drawtext(tags[i], col, urg & 1 << i);
+		drawsquare(m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
+		           occ & 1 << i, urg & 1 << i, col);
 		dc.x += dc.w;
 	}
 	dc.w = blw = TEXTW(m->ltsymbol);
-	/*drawtext(m->ltsymbol, dc.norm, False);*/
-  drawtext(m->ltsymbol, dc.colors[0], True);
+	drawtext(m->ltsymbol, dc.norm, False);
 	dc.x += dc.w;
 	x = dc.x;
 	if(m == selmon) { /* status is only drawn on selected monitor */
@@ -772,24 +759,19 @@
 			dc.x = x;
 			dc.w = m->ww - x;
 		}
-		/*drawtext(stext, dc.norm, False);*/
-    drawcoloredtext(stext);
+		drawtext(stext, dc.norm, False);
 	}
 	else
 		dc.x = m->ww;
 	if((dc.w = dc.x - x) > bh) {
 		dc.x = x;
 		if(m->sel) {
-			/*col = m == selmon ? dc.sel : dc.norm;*/
-			/*drawtext(m->sel->name, col, False);*/
-			/*drawsquare(m->sel->isfixed, m->sel->isfloating, False, col);*/
-      col = m == selmon ? dc.colors[1] : dc.colors[0];
-      drawtext(m->sel->name, col, True);
-      drawsquare(m->sel->isfixed, m->sel->isfloating, col);
+			col = m == selmon ? dc.sel : dc.norm;
+			drawtext(m->sel->name, col, False);
+			drawsquare(m->sel->isfixed, m->sel->isfloating, False, col);
 		}
 		else
-			/*drawtext(NULL, dc.norm, False);*/
-      drawtext(NULL, dc.colors[0], False);
+			drawtext(NULL, dc.norm, False);
 	}
 	XCopyArea(dpy, dc.drawable, m->barwin, dc.gc, 0, 0, m->ww, bh, 0, 0);
 	XSync(dpy, False);
@@ -804,43 +786,10 @@
 }
 
 void
-/*drawsquare(Bool filled, Bool empty, Bool invert, unsigned long col[ColLast]) {*/
-	/*int x;*/
-drawcoloredtext(char *text) {
-  Bool first=True;
-  char *buf = text, *ptr = buf, c = 1;
-  unsigned long *col = dc.colors[0];
-  int i, ox = dc.x;
-
-  while( *ptr ) {
-    for( i = 0; *ptr < 0 || *ptr > NUMCOLORS; i++, ptr++);
-    if( !*ptr ) break;
-    c=*ptr;
-    *ptr=0;
-    if( i ) {
-      dc.w = selmon->ww - dc.x;
-      drawtext(buf, col, first);
-      dc.x += textnw(buf, i) + textnw(&c,1);
-      if( first ) dc.x += ( dc.font.ascent + dc.font.descent ) / 2;
-      first = False;
-    } else if( first ) {
-      ox = dc.x += textnw(&c,1);
-    }
-    *ptr = c;
-    col = dc.colors[ c-1 ];
-    buf = ++ptr;
-  }
-  if( !first ) dc.x -= ( dc.font.ascent + dc.font.descent ) / 2;
-  drawtext(buf, col, True);
-  dc.x = ox;
-}
-
+drawsquare(Bool filled, Bool empty, Bool invert, unsigned long col[ColLast]) {
+	int x;
 
-	/*XSetForeground(dpy, dc.gc, col[invert ? ColBG : ColFG]);*/
-void
-drawsquare(Bool filled, Bool empty, unsigned long col[ColLast]) {
-  int x;
-  XSetForeground(dpy, dc.gc, col[ColFG]);
+	XSetForeground(dpy, dc.gc, col[invert ? ColBG : ColFG]);
 	x = (dc.font.ascent + dc.font.descent + 2) / 4;
 	if(filled)
 		XFillRectangle(dpy, dc.drawable, dc.gc, dc.x+1, dc.y+1, x+1, x+1);
@@ -849,21 +798,17 @@
 }
 
 void
-/*drawtext(const char *text, unsigned long col[ColLast], Bool invert) {*/
-drawtext(const char *text, unsigned long col[ColLast], Bool pad) {
+drawtext(const char *text, unsigned long col[ColLast], Bool invert) {
 	char buf[256];
 	int i, x, y, h, len, olen;
 
-	/*XSetForeground(dpy, dc.gc, col[invert ? ColFG : ColBG]);*/
-  XSetForeground(dpy, dc.gc, col[ColBG]);
+	XSetForeground(dpy, dc.gc, col[invert ? ColFG : ColBG]);
 	XFillRectangle(dpy, dc.drawable, dc.gc, dc.x, dc.y, dc.w, dc.h);
 	if(!text)
 		return;
 	olen = strlen(text);
-	/*h = dc.font.ascent + dc.font.descent;*/
-	/*y = dc.y + (dc.h / 2) - (h / 2) + dc.font.ascent;*/
-  h = pad ? (dc.font.ascent + dc.font.descent) : 0;
-  y = dc.y + ((dc.h + dc.font.ascent - dc.font.descent) / 2);
+	h = dc.font.ascent + dc.font.descent;
+	y = dc.y + (dc.h / 2) - (h / 2) + dc.font.ascent;
 	x = dc.x + (h / 2);
 	/* shorten text if necessary */
 	for(len = MIN(olen, sizeof buf); len && textnw(text, len) > dc.w - h; len--);
@@ -872,8 +817,7 @@
 	memcpy(buf, text, len);
 	if(len < olen)
 		for(i = len; i && i > len - 3; buf[--i] = '.');
-	/*XSetForeground(dpy, dc.gc, col[invert ? ColBG : ColFG]);*/
-  XSetForeground(dpy, dc.gc, col[ColFG]);
+	XSetForeground(dpy, dc.gc, col[invert ? ColBG : ColFG]);
 	if(dc.font.set)
 		XmbDrawString(dpy, dc.drawable, dc.font.set, dc.gc, x, y, buf, len);
 	else
@@ -909,26 +853,12 @@
 }
 
 void
-window_opacity_set(Client *c, double opacity) {
-  if(opacity > 0 && opacity <= 1) {
-    unsigned long real_opacity[] = { opacity * 0xffffffff };
-    XChangeProperty(dpy, c->win, netatom[NetWMWindowOpacity], XA_CARDINAL, 32, PropModeReplace, (unsigned char *)real_opacity, 1);
-  }
-  else {
-    XDeleteProperty(dpy, c->win, netatom[NetWMWindowOpacity]);
-  }
-}
-
-void
 focus(Client *c) {
 	if(!c || !ISVISIBLE(c))
 		for(c = selmon->stack; c && !ISVISIBLE(c); c = c->snext);
 	/* was if(selmon->sel) */
 	if(selmon->sel && selmon->sel != c)
 		unfocus(selmon->sel, False);
-
-  if(selmon->sel && c!=selmon->sel && c && (!root || (selmon->sel->win!=root && c->win!=root)) ) window_opacity_set(selmon->sel, shade);
-  if(c && c!=selmon->sel && (!root || (c->win!=root)) ) window_opacity_set(c, c->opacity);
 	if(c) {
 		if(c->mon != selmon)
 			selmon = c->mon;
@@ -937,15 +867,13 @@
 		detachstack(c);
 		attachstack(c);
 		grabbuttons(c, True);
-		/*XSetWindowBorder(dpy, c->win, dc.sel[ColBorder]);*/
-		XSetWindowBorder(dpy, c->win, dc.colors[1][ColBorder]);
+		XSetWindowBorder(dpy, c->win, dc.sel[ColBorder]);
 		setfocus(c);
 	}
 	else
 		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
 	selmon->sel = c;
 	drawbars();
-  if(c) window_opacity_set(c, c->opacity);
 }
 
 void
@@ -1180,7 +1108,7 @@
 		die("fatal: could not malloc() %u bytes\n", sizeof(Client));
 	c->win = w;
 	updatetitle(c);
-	if(XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans)) && (c->opacity = -1)) {
+	if(XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
 		c->mon = t->mon;
 		c->tags = t->tags;
 	}
@@ -1213,8 +1141,7 @@
 	}
 	wc.border_width = c->bw;
 	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
-	/*XSetWindowBorder(dpy, w, dc.norm[ColBorder]);*/
-	XSetWindowBorder(dpy, w, dc.colors[0][ColBorder]);
+	XSetWindowBorder(dpy, w, dc.norm[ColBorder]);
 	configure(c); /* propagates border_width, if size doesn't change */
 	updatesizehints(c);
 	updatewmhints(c);
@@ -1624,25 +1551,19 @@
 	netatom[NetActiveWindow] = XInternAtom(dpy, "_NET_ACTIVE_WINDOW", False);
 	netatom[NetSupported] = XInternAtom(dpy, "_NET_SUPPORTED", False);
 	netatom[NetWMName] = XInternAtom(dpy, "_NET_WM_NAME", False);
-  netatom[NetWMWindowOpacity] = XInternAtom(dpy, "_NET_WM_WINDOW_OPACITY", False);
 	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
 	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
 	/* init cursors */
-	cursor[CurNormal] = XCreateFontCursor(dpy, XC_right_ptr);
+	cursor[CurNormal] = XCreateFontCursor(dpy, XC_left_ptr);
 	cursor[CurResize] = XCreateFontCursor(dpy, XC_sizing);
 	cursor[CurMove] = XCreateFontCursor(dpy, XC_fleur);
 	/* init appearance */
-	/*dc.norm[ColBorder] = getcolor(normbordercolor);*/
-	/*dc.norm[ColBG] = getcolor(normbgcolor);*/
-	/*dc.norm[ColFG] = getcolor(normfgcolor);*/
-	/*dc.sel[ColBorder] = getcolor(selbordercolor);*/
-	/*dc.sel[ColBG] = getcolor(selbgcolor);*/
-	/*dc.sel[ColFG] = getcolor(selfgcolor);*/
-  for(int i=0; i<NUMCOLORS; i++) {
-    dc.colors[i][ColBorder] = getcolor( colors[i][ColBorder] );
-    dc.colors[i][ColFG] = getcolor( colors[i][ColFG] );
-    dc.colors[i][ColBG] = getcolor( colors[i][ColBG] );
-  }
+	dc.norm[ColBorder] = getcolor(normbordercolor);
+	dc.norm[ColBG] = getcolor(normbgcolor);
+	dc.norm[ColFG] = getcolor(normfgcolor);
+	dc.sel[ColBorder] = getcolor(selbordercolor);
+	dc.sel[ColBG] = getcolor(selbgcolor);
+	dc.sel[ColFG] = getcolor(selfgcolor);
 	dc.drawable = XCreatePixmap(dpy, root, DisplayWidth(dpy, screen), bh, DefaultDepth(dpy, screen));
 	dc.gc = XCreateGC(dpy, root, 0, NULL);
 	XSetLineAttributes(dpy, dc.gc, 1, LineSolid, CapButt, JoinMiter);
@@ -1806,8 +1727,7 @@
 	if(!c)
 		return;
 	grabbuttons(c, False);
-  /*XSetWindowBorder(dpy, c->win, dc.norm[ColBorder]);*/
-  XSetWindowBorder(dpy, c->win, dc.colors[0][ColBorder]);
+	XSetWindowBorder(dpy, c->win, dc.norm[ColBorder]);
 	if(setfocus)
 		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
 }
